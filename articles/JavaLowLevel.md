В этой статье я разбираю внутреннее устройство Java — от базовых компонентов до деталей исполнения кода. Начнём с самого фундамента: из чего состоит Java-среда и какие элементы обеспечивают её работу на разных уровнях.

## ==Основные компоненты Java==
- **JDK (Java Development Kit)** — это наиболее полный комплект, включающий:
    - Средства разработки (`javac`, `javadoc`, `jar` и т.д.)
    - JRE, а значит — и всё необходимое для выполнения программ

- **JRE (Java Runtime Environment)** — это часть JDK, предназначенная только для запуска Java-программ. Без неё программа не запустится, потому что она содержит:    
    - JVM
    - Библиотеки, классы и ресурсы, нужные во время исполнения

- **JVM (Java Virtual Machine)** — это часть JRE, которая:    
    - Исполняет байт-код (`.class`)
    - Управляет памятью (включая сборщик мусора)
    - Обеспечивает переносимость, безопасность и многопоточность

```
JDK = JRE + инструменты разработки
JRE = JVM + стандартные библиотеки
JVM = ядро, исполняющее байт-код
```

## ==JVM==
**JVM (Java Virtual Machine)** — это абстрактная вычислительная машина, которая исполняет байт-код Java. Она изолирует программу от конкретной платформы (Windows, Linux, macOS и т.д.), обеспечивая кроссплатформенность.

Ты компилируешь `.java` в `.class` — и получаешь байт-код. Этот байт-код не зависит от операционной системы. Его уже интерпретирует и/или компилирует JVM, установленная на конкретной платформе.

---
### <mark style="background: #B8C06E;">Class Loader Subsystem</mark>
Это часть JVM, которая:
- Находит `.class` файлы (или другие источники байт-кода)
- Загружает их в память
- Проверяет, подготавливает и связывает классы
- Делает их доступными для исполнения
Классы в Java не загружаются все сразу — только по мере необходимости (ленивая загрузка).

#### Основные компоненты Class Loader Subsystem
##### 1. Bootstrap ClassLoader
- Самый первый загрузчик.
- Написан на **C++** и является частью JVM.
- Загружает основные классы Java из `JAVA_HOME/lib` (например: `java.lang.*`, `java.util.*`).

##### 2. Extension ClassLoader
- Загружает классы из каталога `JAVA_HOME/lib/ext` или из `java.ext.dirs`.
- Например, если ты добавляешь внешние расширения.

##### 3. Application (System) ClassLoader
- Загружает классы из **classpath** — то, с чем ты обычно работаешь (`src`, `bin`, JAR-файлы).
- Используется для загрузки твоего кода.

##### 4. Custom ClassLoaders
- Ты можешь сам написать свой загрузчик, например:
    - Загружать классы из базы данных
    - Из шифрованного архива
    - Из сети

#### Принцип делегирования (Delegation Model)
Ключевая идея — **загрузчик сначала делегирует загрузку родителю**, и только если родитель не справился, загружает сам.
```plaintext
ApplicationClassLoader
     ↓
ExtensionClassLoader
     ↓
BootstrapClassLoader
```
Почему так:
- Чтобы избежать конфликтов и переопределения основных системных классов.
- Пример: если ты создашь свой `java.lang.String`, он не загрузится, потому что `Bootstrap ClassLoader` уже загрузил оригинальный

#### Жизненный цикл загрузки класса (Phases of Class Loading)
1. **Loading (Загрузка)**
    - ClassLoader читает `.class` файл и создает объект `java.lang.Class`.

2. **Linking (Связывание)**    
    - **Verification** — проверка байт-кода на корректность
    - **Preparation** — выделение памяти под поля класса, инициализация значениями по умолчанию
    - **Resolution** — разрешение ссылок на другие классы (на этапе исполнения)

3. **Initialization (Инициализация)**    
    - Выполняется статический блок `static {}`
    - Инициализируются статические поля

---
##### Loading (Загрузка класса)
**Loading** — это первая фаза в процессе работы Class Loader Subsystem.
Её задача — найти, считать и создать объект `Class`, представляющий байт-код в памяти JVM.
1. **Идентификация класса по имени** (например, `"com.example.MyClass"`)
2. **Поиск соответствующего `.class` файла**
    - В файловой системе
    - В JAR-файле
    - Через сетевой источник
    - Из базы данных (в случае custom loader’а)

3. **Чтение байт-кода**    
4. **Создание объекта `java.lang.Class`**, который представляет загруженный класс в памяти
После этого класс ещё не готов к использованию — он просто загружен в JVM. Все поля имеют значения по умолчанию. Логика начнёт исполняться позже, на этапе инициализации.

---
##### Verification
Verification — это этап, на котором JVM проверяет байт-код загружаемого класса, чтобы убедиться, что он:
- **Корректен по структуре**
- **Безопасен для исполнения**
- **Не нарушает границы памяти**
- **Не приводит к нестабильной работе JVM**

---
#### Preparation
**Preparation** — это фаза, на которой JVM:
1. Создаёт память для всех статических переменных класса (static fields)
2. Инициализирует их значениями по умолчанию  
    (например, `0` для чисел, `null` для ссылок, `false` для `boolean` и т.д.)
При этом не выполняется никакой пользовательский код (например, `static {}` блоки и явная инициализация значениями типа `static int a = 5` — это уже следующая фаза Initialization).

Эта фаза **работает только со static-переменными**  
Нестатические поля (обычные переменные объекта) не инициализируются здесь — они создаются только при создании объекта (`new`).

Подготовка выполняется один раз на весь класс, при первом его использовании.

---
##### Resolution
**Resolution (разрешение ссылок)** — это фаза, на которой JVM разрешает символические ссылки в байт-коде на реальные объекты, классы, поля и методы в памяти.

##### Символическая ссылка
Когда компилятор `.java → .class`, он не встраивает прямые ссылки, а сохраняет их как символические:
- Имя класса: `java/io/PrintStream`
- Имя метода: `println`
- Сигнатура: `(Ljava/lang/String;)V`

JVM на этапе Resolution:
- Находит нужный класс (если не найден — загружает)
- Проверяет его
- Связывает ссылку с реальной сущностью в памяти

По спецификации JVM — может быть выполнен немедленно (в момент Linking)
Но чаще выполняется "лениво" — при первом использовании (напр. первый вызов метода)

---
##### Initialization
**Initialization (Инициализация)** — это фаза, на которой JVM выполняет статические инициализации класса:
- `static { ... }` блоки
- выражения `static int a = 5;`
- инициализацию `static final` переменных

JVM инициализирует класс только один раз за весь срок жизни JVM, и только при первом активном использовании класса.

###### Активное использование класса:
- Вызов статического метода
- Обращение к статическому полю, не `final`
- Создание объекта (`new`)
- Вызов `Class.forName("MyClass")`
- Дочерний класс инициализирует родительский класс

###### Не приводит к инициализации:
- Получение ссылки через `.class`: `MyClass.class`
- Компиляция с `static final` полем, подставленным во время компиляции
- Проверка наличия класса с помощью `instanceof`

###### Пример — полная цепочка
```java
public class InitExample {
    static int a = printInit("Статическая переменная a");

    static {
        System.out.println("Статический блок инициализации");
    }

    static int printInit(String msg) {
        System.out.println(msg);
        return 42;
    }

    public static void main(String[] args) {
        System.out.println("main запущен");
    }
}
```
###### Что произойдёт:
1. Класс `InitExample` ещё не инициализирован
2. JVM вызывает `main()` → класс используется впервые
3. JVM запускает **Initialization**:
    - `a = printInit(...)` → выводит `"Статическая переменная a"`
    - `static {}` → выводит `"Статический блок"`
4. Только потом исполняется `main`

##### Пример с `static final`
```java
public class Constants {
    public static final int VALUE = 42;
}
```

```java
public class UseConstants {
    public static void main(String[] args) {
        System.out.println(Constants.VALUE);
    }
}
```
JVM может не инициализировать класс `Constants` вообще, если значение `VALUE` было подставлено во время компиляции (inlined constant).

> Если ты изменишь `VALUE = 99` и пересоберёшь только `Constants.java`, `UseConstants.class` всё равно будет выводить `42`, пока ты не пересоберёшь и его.


##### Инициализация суперклассов
Когда инициализируется класс — JVM сначала инициализирует его суперкласс.
```java
class A {
    static {
        System.out.println("A инициализирован");
    }
}

class B extends A {
    static {
        System.out.println("B инициализирован");
    }
}

public class Test {
    public static void main(String[] args) {
        B b = new B(); // создаёт объект B
    }
}
```

###### Вывод:
```plaintext
A инициализирован
B инициализирован
```
Даже если ты не используешь `A` напрямую, он будет инициализирован **перед** `B`.
