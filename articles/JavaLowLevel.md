В этой статье я разбираю внутреннее устройство Java — от базовых компонентов до деталей исполнения кода. Начнём с самого фундамента: из чего состоит Java-среда и какие элементы обеспечивают её работу на разных уровнях.

## <mark style="background: #64B8CDCC;">⎔ Основные компоненты Java</mark>
- **JDK (Java Development Kit)** — это наиболее полный комплект, включающий:
    - Средства разработки (`javac`, `javadoc`, `jar` и т.д.)
    - JRE, а значит — и всё необходимое для выполнения программ

- **JRE (Java Runtime Environment)** — это часть JDK, предназначенная только для запуска Java-программ. Без неё программа не запустится, потому что она содержит:    
    - JVM
    - Библиотеки, классы и ресурсы, нужные во время исполнения

- **JVM (Java Virtual Machine)** — это часть JRE, которая:    
    - Исполняет байт-код (`.class`)
    - Управляет памятью (включая сборщик мусора)
    - Обеспечивает переносимость, безопасность и многопоточность

```
JDK = JRE + инструменты разработки
JRE = JVM + стандартные библиотеки
JVM = ядро, исполняющее байт-код
```

## <mark style="background: #64B8CDCC;">⎔ JVM</mark>
**JVM (Java Virtual Machine)** — это абстрактная вычислительная машина, которая исполняет байт-код Java. Она изолирует программу от конкретной платформы (Windows, Linux, macOS и т.д.), обеспечивая кроссплатформенность.

Ты компилируешь `.java` в `.class` — и получаешь байт-код. Этот байт-код не зависит от операционной системы. Его уже интерпретирует и/или компилирует JVM, установленная на конкретной платформе.

---
### <mark style="background: #B8C06E;">⋄ Class Loader Subsystem</mark>
Это часть JVM, которая:
- Находит `.class` файлы (или другие источники байт-кода)
- Загружает их в память
- Проверяет, подготавливает и связывает классы
- Делает их доступными для исполнения
Классы в Java не загружаются все сразу — только по мере необходимости (ленивая загрузка).

##### <mark style="background: #76BC6BCF;">▹ Основные компоненты Class Loader Subsystem</mark>
##### 1. Bootstrap ClassLoader
- Самый первый загрузчик.
- Написан на **C++** и является частью JVM.
- Загружает основные классы Java из `JAVA_HOME/lib` (например: `java.lang.*`, `java.util.*`).

##### 2. Extension ClassLoader
- Загружает классы из каталога `JAVA_HOME/lib/ext` или из `java.ext.dirs`.
- Например, если ты добавляешь внешние расширения.

##### 3. Application (System) ClassLoader
- Загружает классы из **classpath** — то, с чем ты обычно работаешь (`src`, `bin`, JAR-файлы).
- Используется для загрузки твоего кода.

##### 4. Custom ClassLoaders
- Ты можешь сам написать свой загрузчик, например:
    - Загружать классы из базы данных
    - Из шифрованного архива
    - Из сети

##### <mark style="background: #76BC6BCF;">▹ Принцип делегирования (Delegation Model)</mark>
Ключевая идея — **загрузчик сначала делегирует загрузку родителю**, и только если родитель не справился, загружает сам.
```plaintext
ApplicationClassLoader
     ↓
ExtensionClassLoader
     ↓
BootstrapClassLoader
```
Почему так:
- Чтобы избежать конфликтов и переопределения основных системных классов.
- Пример: если ты создашь свой `java.lang.String`, он не загрузится, потому что `Bootstrap ClassLoader` уже загрузил оригинальный

##### <mark style="background: #76BC6BCF;">▹ Жизненный цикл загрузки класса (Phases of Class Loading)</mark>
1. **Loading (Загрузка)**
    - ClassLoader читает `.class` файл и создает объект `java.lang.Class`.

2. **Linking (Связывание)**    
    - **Verification** — проверка байт-кода на корректность
    - **Preparation** — выделение памяти под поля класса, инициализация значениями по умолчанию
    - **Resolution** — разрешение ссылок на другие классы (на этапе исполнения)

3. **Initialization (Инициализация)**    
    - Выполняется статический блок `static {}`
    - Инициализируются статические поля

---
##### <mark style="background: #76BC6BCF;">▹ Loading (Загрузка класса)</mark>
**Loading** — это первая фаза в процессе работы Class Loader Subsystem.
Её задача — найти, считать и создать объект `Class`, представляющий байт-код в памяти JVM.
1. **Идентификация класса по имени** (например, `"com.example.MyClass"`)
2. **Поиск соответствующего `.class` файла**
    - В файловой системе
    - В JAR-файле
    - Через сетевой источник
    - Из базы данных (в случае custom loader’а)

3. **Чтение байт-кода**    
4. **Создание объекта `java.lang.Class`**, который представляет загруженный класс в памяти
После этого класс ещё не готов к использованию — он просто загружен в JVM. Все поля имеют значения по умолчанию. Логика начнёт исполняться позже, на этапе инициализации.

---
##### <mark style="background: #76BC6BCF;">▹ Verification</mark>
Verification — это этап, на котором JVM проверяет байт-код загружаемого класса, чтобы убедиться, что он:
- **Корректен по структуре**
- **Безопасен для исполнения**
- **Не нарушает границы памяти**
- **Не приводит к нестабильной работе JVM**

---
##### <mark style="background: #76BC6BCF;">▹ Preparation</mark>
**Preparation** — это фаза, на которой JVM:
1. Создаёт память для всех статических переменных класса (static fields)
2. Инициализирует их значениями по умолчанию  
    (например, `0` для чисел, `null` для ссылок, `false` для `boolean` и т.д.)
При этом не выполняется никакой пользовательский код (например, `static {}` блоки и явная инициализация значениями типа `static int a = 5` — это уже следующая фаза Initialization).

Эта фаза **работает только со static-переменными**  
Нестатические поля (обычные переменные объекта) не инициализируются здесь — они создаются только при создании объекта (`new`).

Подготовка выполняется один раз на весь класс, при первом его использовании.

---
##### <mark style="background: #76BC6BCF;">▹ Resolution</mark>
**Resolution (разрешение ссылок)** — это фаза, на которой JVM разрешает символические ссылки в байт-коде на реальные объекты, классы, поля и методы в памяти.

##### Символическая ссылка
Когда компилятор `.java → .class`, он не встраивает прямые ссылки, а сохраняет их как символические:
- Имя класса: `java/io/PrintStream`
- Имя метода: `println`
- Сигнатура: `(Ljava/lang/String;)V`

JVM на этапе Resolution:
- Находит нужный класс (если не найден — загружает)
- Проверяет его
- Связывает ссылку с реальной сущностью в памяти

По спецификации JVM — может быть выполнен немедленно (в момент Linking)
Но чаще выполняется "лениво" — при первом использовании (напр. первый вызов метода)

---
##### <mark style="background: #76BC6BCF;">▹ Initialization</mark>
**Initialization (Инициализация)** — это фаза, на которой JVM выполняет статические инициализации класса:
- `static { ... }` блоки
- выражения `static int a = 5;`
- инициализацию `static final` переменных

JVM инициализирует класс только один раз за весь срок жизни JVM, и только при первом активном использовании класса.

###### Активное использование класса:
- Вызов статического метода
- Обращение к статическому полю, не `final`
- Создание объекта (`new`)
- Вызов `Class.forName("MyClass")`
- Дочерний класс инициализирует родительский класс

###### Не приводит к инициализации:
- Получение ссылки через `.class`: `MyClass.class`
- Компиляция с `static final` полем, подставленным во время компиляции
- Проверка наличия класса с помощью `instanceof`

###### Пример — полная цепочка
```java
public class InitExample {
    static int a = printInit("Статическая переменная a");

    static {
        System.out.println("Статический блок инициализации");
    }

    static int printInit(String msg) {
        System.out.println(msg);
        return 42;
    }

    public static void main(String[] args) {
        System.out.println("main запущен");
    }
}
```
###### Что произойдёт:
1. Класс `InitExample` ещё не инициализирован
2. JVM вызывает `main()` → класс используется впервые
3. JVM запускает **Initialization**:
    - `a = printInit(...)` → выводит `"Статическая переменная a"`
    - `static {}` → выводит `"Статический блок"`
4. Только потом исполняется `main`

##### Пример с `static final`
```java
public class Constants {
    public static final int VALUE = 42;
}
```

```java
public class UseConstants {
    public static void main(String[] args) {
        System.out.println(Constants.VALUE);
    }
}
```
JVM может не инициализировать класс `Constants` вообще, если значение `VALUE` было подставлено во время компиляции (inlined constant).

> Если ты изменишь `VALUE = 99` и пересоберёшь только `Constants.java`, `UseConstants.class` всё равно будет выводить `42`, пока ты не пересоберёшь и его.


##### Инициализация суперклассов
Когда инициализируется класс — JVM сначала инициализирует его суперкласс.
```java
class A {
    static {
        System.out.println("A инициализирован");
    }
}

class B extends A {
    static {
        System.out.println("B инициализирован");
    }
}

public class Test {
    public static void main(String[] args) {
        B b = new B(); // создаёт объект B
    }
}
```

###### Вывод:
```plaintext
A инициализирован
B инициализирован
```
Даже если ты не используешь `A` напрямую, он будет инициализирован **перед** `B`.

---
### <mark style="background: #B8C06E;">⋄ Runtime Data Areas</mark>
**Runtime Data Areas** — это области памяти, которые JVM выделяет во время выполнения программы.
Основные Runtime Data Areas:
- Method Area
- Heap
- Stack
- PC Register
- Native Method Stack

##### <mark style="background: #76BC6BCF;">▹ Method Area (Metaspace)</mark>
**Method Area** — это общая область памяти в JVM, где хранятся:
1. Структуры классов, загруженных JVM
2. Методы и поля (их метаинформация, не значения!)
3. Байт-код методов
4. Пул констант (constant pool)
5. Статические переменные (`static`)
6. Метаданные об интерфейсах, суперклассах, модификаторах доступа и т.д.

##### Что конкретно хранится в Method Area?
Допустим, у нас есть такой класс:
```java
public class Person {
    static String species = "Homo sapiens";

    private String name;
    private int age;

    public void sayHello() {
        System.out.println("Hello, I am " + name);
    }
}
```
После загрузки класса `Person` в JVM, в Method Area будет храниться:

|Что|Пример|
|---|---|
|Имя класса|`Person`|
|Поля|`name: String`, `age: int`, `species: static`|
|Методы|`sayHello()`, `toString()`, `hashCode()` и т.п.|
|Пул констант|Ссылки на строки (`"Hello..."`, `"Homo sapiens"`)|
|Ссылки на суперклассы|`java.lang.Object`|
|Модификаторы доступа|`public`, `private`, `static`, и т.д.|
|Байт-код метода|инструкции `sayHello()`|

Можно проанализировать эту информацию:
```bash
javap -verbose Example
```

##### Как JVM использует Method Area?
1. **ClassLoader** загружает `.class` файл
2. JVM размещает **метаинформацию класса** в **Method Area**
3. Если вызывается метод — JVM берёт его **байт-код** из Method Area
4. Статические поля инициализируются в фазе **Initialization**, и их значения хранятся здесь же

##### <mark style="background: #76BC6BCF;">▹ Heap</mark>
**Heap** — это динамическая область памяти, общая для всех потоков, в которой:
- хранятся объекты (`new Object()`)
- хранятся массивы

Объекты в Heap живут до тех пор, пока на них существуют ссылки. Когда ссылки исчезают — объект считается "мусором", и его может убрать сборщик мусора (GC).

##### Young Generation
- Новые объекты сначала попадают сюда
- Самая частая зона для Minor GC
- Подразделяется на: 
    - Eden — всё новое создаётся здесь
    - Survivor S0/S1 — "выжившие" объекты перекидываются сюда

##### Old Generation (Tenured)
- Объекты, которые пережили несколько сборок
- Считаются "долго живущими"
- Чистятся реже (Full GC)

##### <mark style="background: #76BC6BCF;">▹ Stack</mark>
**JVM Stack** — это область памяти, выделенная каждому потоку, где:
- хранятся фреймы (stack frames) вызванных методов,
- размещаются локальные переменные,
- используется операндный стек для выполнения байт-кода,
- хранится адрес возврата (куда вернуться после вызова метода).

##### Stack Frame
Когда вызывается метод, JVM создаёт stack frame, в котором:
1. Local Variables — локальные переменные метода
2. Operand Stack — временные значения (результаты выражений)
3. Reference to Constant Pool — для доступа к строкам, методам, полям
4. Return Address — куда вернуться после окончания метода
После завершения метода его фрейм удаляется из стека.

Java — stack-based virtual machine, т.е. почти все операции выполняются через операндный стек, а не через регистры (как в CPU).

##### <mark style="background: #76BC6BCF;">▹ PC</mark>
**PC Register (регистр счётчика команд)** — это маленькая служебная область памяти, связанная с каждым потоком, которая хранит адрес текущей инструкции байт-кода, исполняемой JVM.

| Свойство                  | Описание                                                                 |
| ------------------------- | ------------------------------------------------------------------------ |
| Потоковая область         | У каждого потока свой PC-регистр (так как потоки исполняются независимо) |
| Указывает на байт-код     | PC хранит смещение текущей инструкции в методе (`offset`)                |
| Автоматически обновляется | JVM обновляет его при выполнении каждой инструкции                       |

##### <mark style="background: #76BC6BCF;">▹ Native Method Stack</mark>
**Native Method Stack** — это область памяти, которая:
- создаётся для каждого потока (как и JVM Stack),
- используется для вызова и исполнения нативных (native) методов,  
    т.е. написанных не на Java, а на C/C++,
- взаимодействует с JNI (Java Native Interface).

> Java-программа может вызывать функции ОС, аппаратные API или использовать оптимизированный C-код — именно тогда работает Native Stack.

### <mark style="background: #B8C06E;">⋄ javap</mark>
**`javap`** — это дизассемблер Java-классов, т.е. программа, которая:
- читает `.class` файлы (скомпилированный Java-код),
- и показывает их внутреннюю структуру: методы, поля, байт-код, модификаторы, сигнатуры и т.д.

> `javap` входит в состав `JDK`, находится в папке `bin/`, и запускается из терминала.

| Назначение                        | Что можно делать                                              |
| --------------------------------- | ------------------------------------------------------------- |
| Изучение байт-кода                | Посмотреть, как Java-компилятор преобразует код в инструкции  |
| Анализ производительности         | Увидеть лишние методы, автогенерацию, лямбды, `bridge`-методы |
| Отладка                           | Проверить, что попало в `.class` файл                         |
| Инспекция модификаторов           | Увидеть `final`, `static`, `synthetic`                        |
| Работа с компиляторами            | Анализ кода, сгенерированного ломбоком, джаксб, дженериками   |
| Безопасность / обратная инженерия | Понять структуру кода даже без `.java` файлов                 |

##### Ключевые опции `javap`

| Опция        | Назначение                                            |
| ------------ | ----------------------------------------------------- |
| `-c`         | Показать **байт-код** методов (`disassembly`)         |
| `-p`         | Показать все члены, включая `private`                 |
| `-s`         | Показать сигнатуры (для дженериков)                   |
| `-verbose`   | Очень подробный вывод (пул констант, атрибуты)        |
| `-l`         | Показать таблицу локальных переменных (если доступно) |
| `-sysinfo`   | Выводит техническую информацию о .class               |
| `-constants` | Показывает только `static final` константы            |
| `-classpath` | Указание, где искать классы                           |

### <mark style="background: #B8C06E;">⋄ Реализация JVM</mark>
**JVM (Java Virtual Machine)** — это абстрактная спецификация, описанная в документации Java (Java Virtual Machine Specification).
> Но реализация JVM — это реальная программа**, написанная на C/C++ (или других языках), которая выполняет Java-байт-код в соответствии с этой спецификацией.

У каждой реализации:
- своя производительность,
- разные алгоритмы сборки мусора (GC),
- разные JIT-компиляторы,
- разный подход к многопоточности, работе с нативным кодом и профилированию.

##### Основные реализации JVM

| Реализация      | Разработчик      | Особенности                           | Где используется                   |
| --------------- | ---------------- | ------------------------------------- | ---------------------------------- |
| **HotSpot**     | Oracle / OpenJDK | Дефолтная JVM, стабильно, GC, JIT     | Везде                              |
| **GraalVM**     | Oracle Labs      | AOT, многоязычность, быстрый startup  | Микросервисы, serverless, polyglot |
| **OpenJ9**      | IBM / Eclipse    | Маленький footprint, быстрая загрузка | Облака, Docker, IoT                |
| **Zing (Azul)** | Azul Systems     | C4 GC, без пауз, high-perf            | Финансы, real-time                 |
| **ART/Dalvik**  | Google           | Для Android, AOT/JIT                  | Только Android                     |
